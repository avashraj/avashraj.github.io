<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Journals on putergoon.com</title>
    <link>avashraj.github.io/journal/</link>
    <description>Recent content in Journals on putergoon.com</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 01 Mar 2025 18:25:26 -0800</lastBuildDate>
    <atom:link href="avashraj.github.io/journal/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Mar 01 2025</title>
      <link>avashraj.github.io/journal/mar-01-2025/</link>
      <pubDate>Sat, 01 Mar 2025 18:25:26 -0800</pubDate>
      <guid>avashraj.github.io/journal/mar-01-2025/</guid>
      <description>&lt;h1 id=&#34;i-learned&#34;&gt;i learned&lt;/h1&gt;&#xA;&lt;p&gt;i started the 3blue1brown linear algebra playlist again to brush up on my linear algebra knowledge. A vector can be thought&#xA;of in many different ways. A physicist might think of it as an arrow with a direction and a length. A computer scientist&#xA;might think of it as a list of numbers. They are the same. If we would draw a CS 2d vector on a coordinate plan starting&#xA;at the origin, we would have a 2d arrow with length and direction. We have two operations on these vectors: vector addition&#xA;and scalar multiplication. Vector addition is the addition of two vectors of same length element wise. So if we had&#xA;$$&#xA;\mathbf{a} + \mathbf{b} =&#xA;\begin{bmatrix} a_1 \ a_2 \ a_3 \end{bmatrix} +&#xA;\begin{bmatrix} b_1 \ b_2 \ b_3 \end{bmatrix} =&#xA;\begin{bmatrix} a_1 + b_1 \ a_2 + b_2 \ a_3 + b_3 \end{bmatrix}&#xA;$$&#xA;Similarly for scalar multiplication:&#xA;$$&#xA;\begin{bmatrix} a_1 \ a_2 \ a_3 \end{bmatrix} * 2 =&#xA;\begin{bmatrix} 2a_1 \ 2a_2 \ 2a_3 \end{bmatrix}&#xA;$$&lt;/p&gt;</description>
    </item>
    <item>
      <title>Feb 28 2025</title>
      <link>avashraj.github.io/journal/feb-28-2025/</link>
      <pubDate>Sat, 01 Mar 2025 11:44:18 -0800</pubDate>
      <guid>avashraj.github.io/journal/feb-28-2025/</guid>
      <description>&lt;h1 id=&#34;i-learned&#34;&gt;i learned&lt;/h1&gt;&#xA;&lt;p&gt;I forgot to do this yesterday so I am doing it on March 1st. I was trying to set up postgresql on my vps and connect to it from&#xA;my computer. It wasn&amp;rsquo;t working for so long and Claude figured it out for me. My vps didn&amp;rsquo;t have an ingress rule that allowed&#xA;for remote connections.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Feb 27 2025</title>
      <link>avashraj.github.io/journal/feb-27-25/</link>
      <pubDate>Thu, 27 Feb 2025 23:02:04 -0800</pubDate>
      <guid>avashraj.github.io/journal/feb-27-25/</guid>
      <description>&lt;h1 id=&#34;i-learned&#34;&gt;i learned&lt;/h1&gt;&#xA;&lt;p&gt;Javascript is a single threaded programming language, so code such as network requests would take a lot of time and block the&#xA;main thread. We can avoid this problem with asynchronous code. We can have long tasks such as network requests happen in&#xA;the background without blocking the main thread.&lt;/p&gt;&#xA;&lt;p&gt;Two ways of handling asynchronous data requests are promises, a native JS concept and rxjs observables. Angular uses&#xA;observables primarily in their http system. A promise can get data over a period of time which will return response data&#xA;or an error object. They can only return a single value/object. Promises also cannot handle streams of data. Data streaming&#xA;is sending a large file as chunks at a time. Promises will also fetch data even if no one uses that data.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Feb 26 2025</title>
      <link>avashraj.github.io/journal/feb-26-2025/</link>
      <pubDate>Wed, 26 Feb 2025 13:31:07 -0800</pubDate>
      <guid>avashraj.github.io/journal/feb-26-2025/</guid>
      <description>&lt;h1 id=&#34;i-learned&#34;&gt;i learned&lt;/h1&gt;&#xA;&lt;p&gt;A thread is the smallest unit of execution in a CPU core(or CPU if there is only one core). One important thread function&#xA;is .join() which allows one thread to wait for another thread to finish before resuming execution. For example, if we&#xA;have two threads(A, B) and thread A attempts to join thread B,  A calls B.join(). Thread A would then be set to a blocked state&#xA;and be placed into B&amp;rsquo;s waiting queue. A would remain in a sleeping state until B finishes execution. Once B is finished&#xA;A gets placed back into the ready queue.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Feb 25 2025</title>
      <link>avashraj.github.io/journal/feb-25-2025/</link>
      <pubDate>Tue, 25 Feb 2025 22:00:55 -0800</pubDate>
      <guid>avashraj.github.io/journal/feb-25-2025/</guid>
      <description>&lt;h1 id=&#34;i-learned&#34;&gt;i learned&lt;/h1&gt;&#xA;&lt;p&gt;Today I woke up at 7 am after going to bed at 11 and I felt awesome. Minus the fact that&#xA;I was really fucking sick. my head and body ached and i couldn&amp;rsquo;t think straight. I had to&#xA;complete my calculator app and even though I felt shitty, I was able to go through it&#xA;much faster compared to yesterday. One error I could not figure out that ChatGPT found for&#xA;me was why when I tried to add two numbers it didn&amp;rsquo;t add but simply combined it. Looking&#xA;back on this now I should have realized instantly. The output was getting concatentated&#xA;because I passed in the numbers as strings! I was so mad at myself that I didn&amp;rsquo;t see that.&#xA;Besides that I didn&amp;rsquo;t learn anything else. I had circuit theory lab where we had to make&#xA;more complex circuits with resistors. Breadboards are pretty cool I wish I had one.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Feb 24 2025</title>
      <link>avashraj.github.io/journal/feb-24-2025/</link>
      <pubDate>Mon, 24 Feb 2025 22:11:49 -0800</pubDate>
      <guid>avashraj.github.io/journal/feb-24-2025/</guid>
      <description>&lt;h1 id=&#34;i-learned&#34;&gt;i learned&lt;/h1&gt;&#xA;&lt;p&gt;In operating systems class, I learned about the reader/writer synchronization&#xA;problem. If we are creating a shared document, we need a way for multiple people&#xA;to be able to read it and write it at the same time. The correct solution to this is&#xA;to use locks and monitors to protect the section of code that deals with our logical&#xA;variables. A couple requirements are that only one person can write to the doc at one&#xA;time, as many people as possible need to be able to read from it. (Also this is 12 hours&#xA;after my lecture, I&amp;rsquo;m just trying to active recall it to the best of my ability).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Feb 23 2025</title>
      <link>avashraj.github.io/journal/feb-23-25/</link>
      <pubDate>Sun, 23 Feb 2025 23:00:39 -0800</pubDate>
      <guid>avashraj.github.io/journal/feb-23-25/</guid>
      <description>&lt;h1 id=&#34;i-learned&#34;&gt;i learned&lt;/h1&gt;&#xA;&lt;p&gt;waking up late sucks terribly. learning concepts and being able to apply those concepts are wayyyy different&lt;/p&gt;</description>
    </item>
    <item>
      <title>Feb 22 2025</title>
      <link>avashraj.github.io/journal/feb-22-2025/</link>
      <pubDate>Sat, 22 Feb 2025 22:53:10 -0800</pubDate>
      <guid>avashraj.github.io/journal/feb-22-2025/</guid>
      <description>&lt;h1 id=&#34;i-learned&#34;&gt;i learned&lt;/h1&gt;&#xA;&lt;p&gt;I began designing the system for my friends and I&amp;rsquo;s startup. We will have a MacOS client, an API server, and an external Postgres DB.&#xA;It was pretty fun trying to figure out what was the best options. ChatGPT is a big help because theres so many important things&#xA;that I have no idea about. For example I thought we could just enable HTTPS in our API framework and let it run. While this is possible&#xA;with FastAPI, it is not industry standard. I want to work towards making everything I do standard industry procedure so I can better&#xA;prepare myself for the job market. Instead we would have to enable SSL certificates and have NGINX act as a reverse proxy. A SSL&#xA;certificate (secure socket i forgot the l) encrypts the data. A reverse proxy is a server that points to another server.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Feb 21 2025</title>
      <link>avashraj.github.io/journal/feb-21-2025/</link>
      <pubDate>Sat, 22 Feb 2025 01:20:16 -0800</pubDate>
      <guid>avashraj.github.io/journal/feb-21-2025/</guid>
      <description>&lt;h1 id=&#34;i-learned&#34;&gt;i learned&lt;/h1&gt;&#xA;&lt;p&gt;I studied another slideshow of my circuit theory class and I went over more fundamental concepts.&#xA;Resistance is the capability to stop the flow of current and is the opposite of conductance. The unit for resistance is&#xA;the ohm. This brings me to the first big concept/strategy for solving circuits: Ohm&amp;rsquo;s law. Ohm&amp;rsquo;s law states that the voltage&#xA;across a conductor is proportional to the amount of current that flows through it. $V = IR$&lt;/p&gt;</description>
    </item>
    <item>
      <title>Feb 20 2025</title>
      <link>avashraj.github.io/journal/feb-20-2025/</link>
      <pubDate>Fri, 21 Feb 2025 01:30:15 -0800</pubDate>
      <guid>avashraj.github.io/journal/feb-20-2025/</guid>
      <description>&lt;h3 id=&#34;i-learned&#34;&gt;i learned&lt;/h3&gt;&#xA;&lt;p&gt;I had my computer vision lab in the morning and I spent 99 minutes trying to figure out RANSAC and get it to work. I&#xA;initially thought it was easier than it actually was. I learned how to make the A matrix using numpy. It was just a&#xA;bunch of hardcoded array indexing to put the correct points in the right spots. That took me wayy longer than it should.&#xA;So the homography matrix will help us stitch together two images if they have at least 4 feature matches between the two&#xA;images. We get the features by using SIFT, (something we just use but do not derive). From these SIFT features, we can&#xA;find matches (I forget how we do this its late :(  ) between the two images. If we have at least 4 we can begin our RANSAC&#xA;loop.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Feb 19 2025</title>
      <link>avashraj.github.io/journal/feb-19-2025/</link>
      <pubDate>Wed, 19 Feb 2025 13:56:39 -0800</pubDate>
      <guid>avashraj.github.io/journal/feb-19-2025/</guid>
      <description>&lt;h3 id=&#34;i-learned&#34;&gt;i learned&lt;/h3&gt;&#xA;&lt;p&gt;In the morning I had my operating systems lecture where we discussed various synchronization problems. First, we reviewed&#xA;locks (not review for me becuase I missed the last lecture). Locks are a way to protect critical sections of multithreaded&#xA;code. One way to do this is to disable all interrupts, but this is an insecure method.&lt;/p&gt;&#xA;&lt;p&gt;We introduced the concept of &lt;strong&gt;semaphores&lt;/strong&gt;. A semaphore is a type of lock that has a counter with two methods:&#xA;.p() and .v() The p function checks if the variable (semaphores store a non negative integer) is non zero. If it is&#xA;we decrease it. The v function increments the&#xA;semaphore by one and wakes up sleeping threads waiting to access the shared data. If we were to imagine two subroutines that&#xA;need the same variable, we can initialize a semaphore to 1 and use it to maintain thread safety. Before one subroutine&#xA;accesses that variable we would call &lt;code&gt;semaphore.p()&lt;/code&gt; to lock it. After we run the critical section (code that should not be&#xA;interrupted during its execution) we can call &lt;code&gt;semaphore.v()&lt;/code&gt; to free it.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
